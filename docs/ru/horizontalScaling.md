### Горизонтальное масштабирование

- [Добавление удаленного клона](#Добавление-удаленного-клона)
- [Удаление удаленного клона](#Удаление-удаленного-клона)
- [Обновление функции аутентификации исходящих соединений](#Обновление-функции-аутентификации-исходящих-соединений)
- [Пример](#Пример)

Горизонтальное масштабирование происходит за счет создания **Клонов** копий
серверов. Клоны обмениваются информацией друг с другом. Каждый клон предоставляет
другим клонам, информацию об известных ему клонах. Таким образом происходит
автоматическое построение сети. Клоны общаются между собой системными 
сообщениями. 

Если клиент присылает групповое сообщение или сам клон инициирует групповое
сообщение, то такое сообщение отправляется клиентам данного клона, и всем 
известным удаленным клонам. Удаленные клоны получив такое сообщение, рассылают
своим клиентам и удаленным клонам которым еще не посылалось сообщение.

Если на одном из клонов происходит удаление группы, то удаленным клонам 
отправляется системное сообщение, которое говорит удалить группу. Удаленный
клон отправляет сообщение другим удаленным клонам, которых не было в списке
получателей системного сообщения.

Клоны поддерживают аутентификацию. По умолчанию, клон может подключиться, к
любому удаленному клону без аутентификации. Но если клону задать `authFnIn` 
функцию аутентификации, то она будет проверять каждый удаленный клон при 
попытке подключиться. Функция может быть синхронной или асинхронной, на входе
принимает параметр `authValue`, это значение которое удаленный клон 
предоставляет в качестве аутентификации. Этим значением может быть что угодно,
например `token` или `api key`. Если удаленный клон не проходит проверку, то 
требуется вернуть `false` и соединение удаленного клона разрывается. Если
функцию вернет `true`, то соединение с удаленным клоном устанавливается.

Следует задать функцию `authFnOut`, если удаленные клоны требуют аутентификацию.
Функция может быть синхронной или асинхронной. Должна возвращать значение,
которое удаленный клон будет использовать в процессе аутентификации. Этим значением 
может быть что угодно, например `token` или `api key`.

#### Добавление удаленного клона

Для добавления клона служит метод `addClone`. При добавлении удаленного клона,
клон будет пытаться подключиться к удаленному клону, если находится в активном
состоянии. При подключении передаст данные об известных ему клонах. Так же
передаст информацию о себе, если задан `url`. 

| name | type | description |
| --- | --- | --- |
| id | string | `id` удаленного клона. У одного адреса, на всех клонах, должен быть одинаковый `id`. Если адрес будет одинаковый, а `id` разные, то клон задвоится и начнет получать сообщения по несколько раз |
| url | string | адрес подключения к клону |
| authFnOut | function | Синхронная или асинхронная функция аутентификации исходящих соединений к клонам. Отрабатывает при событии подключения к клону. На входе принимает объект клиента клона (client) к которому подключается. Вернуть должна `authValue`. По этому значению, удаленный клон будет производить аутентификацию. Этим значением может быть что угодно, например токен или api key. |

#### Удаление удаленного клона

Для удаления клона служит метод `deleteClone`.

| name | type | description |
| --- | --- | --- |
| id | string | `id` удаленного клона |

#### Обновление функции аутентификации исходящих соединений

Для обновления `authFnOut` функции аутентификации исходящих соединений,
служит метод `updateAuthFnOut`. Выполнение метода останавливает, подключение
ко всем удаленным клонам, обновляет у каждого клона функцию `authFnOut` и
заново запускает подключение.

#### Пример
```js
  const jrfWS = require('jrf-ws-3');

  // Функция возвращающая значения для аутентификации
  // при подключении к удаленным клонам
  // Отправим токен
  const authFnOut = () => 'token';

  // Функция аутентификации при подключении
  // удаленных клонов к текущему
  // Проверим токен
  const authFnIn = (authValue) => {
    return authValue === 'token';
  };

  // Инициализируем клоны
  const clone1 = new jrfWS.Server({
    id: 'clone1',
    port: 4001,
    // Если знаем адрес, то пропишем,
    // таким образом при подключении
    // к удаленному клону, клон заявит о себе
    url: 'ws://localhost:4001',
    authFnOut,
    authFnIn
  });

  const clone2 = new jrfWS.Server({
    id: 'clone2',
    port: 4002,
    url: 'ws://localhost:4002',
    authFnOut,
    authFnIn
  });

  const clone3 = new jrfWS.Server({
    id: 'clone3',
    port: 4003,
    url: 'ws://localhost:4003',
    authFnOut,
    authFnIn
  });

  const clone4 = new jrfWS.Server({
    id: 'clone4',
    port: 4004,
    url: 'ws://localhost:4004',
    authFnOut,
    authFnIn
  });

  // Запустим клоны
  clone1.start();
  clone2.start();
  clone3.start();
  clone4.start();

  // Расскажем clone1 о clone2 и clone4
  clone1.addClone({id: 'clone2', url: 'ws://localhost:4002'});
  clone1.addClone({id: 'clone4', url: 'ws://localhost:4004'});

  // По умолчанию обмен между клонами происходит каждые 2 секунды
  // поэтому выдержим паузу 4 секунды
  await wait(4000);

  // clone1, clone2, clone4 теперь знают все друг о друге,
  // хотя их добавил лишь clone1
  console.log(clone1.clones.clones.keys()); // [Map Iterator] { 'clone2', 'clone4' }
  console.log(clone2.clones.clones.keys()); // [Map Iterator] { 'clone4', 'clone1' }
  console.log(clone3.clones.clones.keys()); // [Map Iterator] {  }
  console.log(clone4.clones.clones.keys()); // [Map Iterator] { 'clone2', 'clone1' }

  // Для того что бы clone3 узнал о всех удаленных клонах
  // и чтобы удаленные клону узнали о нем
  // достаточно подключить один из удаленных клонов
  clone3.addClone({id: 'clone4', url: 'ws://localhost:4004'});

  await wait(4000);

  console.log(clone1.clones.clones.keys()); // [Map Iterator] { 'clone2', 'clone4', 'clone3' }
  console.log(clone2.clones.clones.keys()); // [Map Iterator] { 'clone4', 'clone1', 'clone3' }
  console.log(clone3.clones.clones.keys()); // [Map Iterator] { 'clone4', 'clone1', 'clone2' }
  console.log(clone4.clones.clones.keys()); // [Map Iterator] { 'clone2', 'clone1', 'clone3' }

  // Остановим клоны
  clone1.stop();
  clone2.stop();
  clone3.stop();
  clone4.stop();
```